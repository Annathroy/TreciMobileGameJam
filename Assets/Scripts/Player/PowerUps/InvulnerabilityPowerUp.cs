using UnityEngine;

[DisallowMultipleComponent]
public class InvulnerabilityPowerUp : PowerUp
{
    private PlayerHealth health;

    [Header("Bubble Visual Effect")]
    [SerializeField] private Sprite bubbleSprite;                           // optional
    [SerializeField] private string defaultBubbleSpritePath = "Sprites/Bubble"; // Resources/Sprites/Bubble.png
    [SerializeField] private Vector2 bubbleSize = new Vector2(5f, 5f);
    [SerializeField] private Vector3 bubbleOffset = new Vector3(0, 1, 0.3f);
    [SerializeField] private Color bubbleTint = Color.white;
    [Range(0f, 1f)][SerializeField] private float bubbleTransparency = 1.0f;
    [SerializeField] private int sortingOrder = 100;                        // render on top

    [Header("Pulse Animation")]
    [SerializeField] private bool enablePulseAnimation = true;
    [SerializeField] private float pulseSpeed = 3f;
    [SerializeField] private float pulseIntensity = 0.15f;

    [Header("Optional Material Override (leave null for auto)")]
    [SerializeField] private Material bubbleMaterialOverride;

    private GameObject bubbleVisual;
    private SpriteRenderer bubbleRenderer;
    private Vector3 baseBubbleScale;

    // --- static caches to avoid leaks/material spam ---
    private static Material s_cachedMat;
    private static Sprite s_generatedSprite;

    protected override void OnActivate()
    {
        EnsureRefs();
        if (!health) return;

        health.GrantInvulnerability(duration);
        CreateBubbleVisual();
    }

    protected override void OnStack(int newCount)
    {
        EnsureRefs();
        if (!health) return;

        health.GrantInvulnerability(duration);
        if (!bubbleVisual) CreateBubbleVisual();
    }

    protected override void OnUnstack(int newCount) { /* no-op */ }

    protected override void OnDeactivate()
    {
        DestroyBubbleVisual();
    }

    private void CreateBubbleVisual()
    {
        if (!player || bubbleVisual != null) return;

        // 1) Ensure we have a sprite (assigned -> Resources -> generated)
        var sprite = GetBubbleSprite();

        if (sprite == null)
        {
            Debug.LogWarning("[InvulnerabilityPowerUp] No bubble sprite could be created or loaded.");
            return;
        }

        // 2) Create object
        bubbleVisual = new GameObject("InvulnerabilityBubble");
        bubbleVisual.transform.SetParent(player.transform, false);
        bubbleVisual.transform.SetAsLastSibling(); // keep on top in hierarchy

        // Face up for top-down; size & offset
        bubbleVisual.transform.localPosition = bubbleOffset;
        bubbleVisual.transform.localRotation = Quaternion.Euler(90f, 0f, 0f);
        bubbleVisual.transform.localScale = new Vector3(bubbleSize.x, bubbleSize.y, 1f);
        baseBubbleScale = bubbleVisual.transform.localScale;

        // 3) Renderer
        bubbleRenderer = bubbleVisual.AddComponent<SpriteRenderer>();
        bubbleRenderer.sprite = sprite;

        var c = bubbleTint; c.a = bubbleTransparency;
        bubbleRenderer.color = c;

        bubbleRenderer.sortingOrder = sortingOrder;

        // 4) Material (auto-resolve to avoid pink in any pipeline)
        bubbleRenderer.sharedMaterial = bubbleMaterialOverride ? bubbleMaterialOverride : GetSpriteMaterial();
    }

    private void DestroyBubbleVisual()
    {
        if (bubbleVisual != null)
        {
            Destroy(bubbleVisual);
            bubbleVisual = null;
        }
        bubbleRenderer = null;
    }

    private void Update()
    {
        // Pulsing automatically freezes when paused (Time.deltaTime == 0)
        if (enablePulseAnimation && bubbleVisual != null)
        {
            float pulse = 1f + Mathf.Sin(Time.time * pulseSpeed) * pulseIntensity;
            bubbleVisual.transform.localScale = baseBubbleScale * pulse;
        }
    }

    private void OnDestroy()
    {
        DestroyBubbleVisual();
        // keep cached material/sprite; they're reused globally
    }

    private void EnsureRefs()
    {
        if (health) return;
        if (!player) return;
        health = player.GetComponent<PlayerHealth>() ?? player.GetComponentInChildren<PlayerHealth>(true);
        if (!health) Debug.LogError("[InvulnerabilityPowerUp] PlayerHealth not found on player.");
    }

    // ----------------- Helpers -----------------

    private Sprite GetBubbleSprite()
    {
        // 1) Explicit assignment
        if (bubbleSprite) return bubbleSprite;

        // 2) Resources path
        if (!string.IsNullOrEmpty(defaultBubbleSpritePath))
        {
            var res = Resources.Load<Sprite>(defaultBubbleSpritePath);
            if (res) return res;
        }

        // 3) Generate once (soft circular sprite)
        if (!s_generatedSprite)
            s_generatedSprite = GenerateCircleSprite(128, 128, 0.48f, 0.06f);

        return s_generatedSprite;
    }

    private Material GetSpriteMaterial()
    {
        if (s_cachedMat) return s_cachedMat;

        // Try URP 2D shaders first (best for SpriteRenderer)
        string[] shaderNames =
        {
            "Universal Render Pipeline/2D/Sprite-Unlit-Default",
            "Universal Render Pipeline/2D/Sprite-Lit-Default",
            // Fallback that works in both built-in and URP (Unity provides a compatible Sprites/Default under URP)
            "Sprites/Default"
        };

        Shader found = null;
        foreach (var name in shaderNames)
        {
            found = Shader.Find(name);
            if (found) break;
        }

        if (!found)
        {
            Debug.LogWarning("[InvulnerabilityPowerUp] No suitable sprite shader found. Bubble may appear pink.");
            return null;
        }

        s_cachedMat = new Material(found)
        {
            name = "[Auto] InvulnBubbleMat"
        };

        // Transparent render queue as a hint
        s_cachedMat.renderQueue = (int)UnityEngine.Rendering.RenderQueue.Transparent;
        return s_cachedMat;
    }

    // Generate a soft circular sprite (white RGBA) so tint/alpha work
    private static Sprite GenerateCircleSprite(int w, int h, float radiusNorm, float featherNorm)
    {
        var tex = new Texture2D(w, h, TextureFormat.RGBA32, false);
        tex.name = "[Auto] BubbleCircle";
        tex.wrapMode = TextureWrapMode.Clamp;
        tex.filterMode = FilterMode.Bilinear;

        float cx = (w - 1) * 0.5f;
        float cy = (h - 1) * 0.5f;
        float maxR = Mathf.Min(cx, cy) * radiusNorm * 2f;     // convert norm to px
        float feather = Mathf.Max(1f, Mathf.Min(cx, cy) * featherNorm);

        Color32[] px = new Color32[w * h];
        for (int y = 0; y < h; y++)
        {
            for (int x = 0; x < w; x++)
            {
                float dx = x - cx;
                float dy = y - cy;
                float d = Mathf.Sqrt(dx * dx + dy * dy);
                float a = Mathf.Clamp01(1f - (d - maxR) / feather); // soft edge
                byte ba = (byte)Mathf.RoundToInt(a * 255f);
                px[y * w + x] = new Color32(255, 255, 255, ba);
            }
        }

        tex.SetPixels32(px);
        tex.Apply(false, false);

        var rect = new Rect(0, 0, w, h);
        var pivot = new Vector2(0.5f, 0.5f);
        return Sprite.Create(tex, rect, pivot, 100f, 0, SpriteMeshType.Tight);
    }
}
